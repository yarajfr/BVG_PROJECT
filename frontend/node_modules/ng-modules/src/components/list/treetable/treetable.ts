export class Treetable {

	calcDeep(item, deep: number = 0) {
		item.map((node, index) => {
			node.$$deep = deep + 1;
			node.$$same = item;
			node.$$index = index;
			node.$$expand = false;
			if (deep == 0) node.$$root = item;
			if (node.children) {
				node.children.map(child => {
					child.$$parent = node;
					if (deep == 0) child.$$root = item;
					else child.$$root = node.$$root;
				})
				this.calcDeep(node.children, deep + 1);
			}
		})
		return item;
	}

	getStatus(list,/**获取唯一标示 */ getOnlyId: (item) => any) {
		let status: string[] = [];
		let statusObj: any = {}
		list.map(item => {
			if (item.$$parent) {
				if (item.$$parent.$$expand) {
					let id = getOnlyId(item.$$parent);
					let str = `${id}_${item.$$parent.$$deep}`
					if (!statusObj[str]) {
						statusObj[str] = true;
						status.push(`${id}_${item.$$parent.$$deep}`);
					}
				}
			}
		})
		return status;
	}

	recoveryStatus(list,/**获取唯一标示 */ getOnlyId: (item) => any, statusData: string[]) {
		let status: any = {}
		statusData.map(item => {
			status[item] = true;
		})
		let findChildren = (list) => {
			list.map(item => {
				let id = getOnlyId(item);
				if (status[`${id}_${item.$$deep}`]) {
					this.expand(item);
				}
				if (item.children) {
					findChildren(item.children);
				}
			})
		}
		findChildren(list);
	}

	calcDeepStyle(item) {
		let style = {
			'padding-left': `${item.$$deep * 10}px`,
		}
		return style;
	}

	findAllExpanded(item) {
		let data = [];
		if (item.$$expand && item.children) {
			data.push(item);
			item.children.map(node => {
				if (node.$$expand) {
					data = data.concat(this.findAllExpanded(node))
				}
			})
		}
		return data;
	}

	compress(item) {
		if (item.$$expand) {
			let parent = item.$$root;
			if (item.children) {
				parent.some((node, i) => {
					if (node == item) {
						if (!item.$$expand) {
						} else {
							let allExpand = this.findAllExpanded(item);
							allExpand.reverse();
							allExpand.map(item => {
								item.$$root.some((node, index) => {
									if (node == item) {
										item.$$root.splice(index + 1, node.children.length);
										item.$$expand = !item.$$expand;
										return true;
									}
								})
							})
						}
						return true;
					}
				})
			}
		}
	}

	expand(item) {
		if (item.$$expand) {
			this.compress(item);
		}
		let parent = item.$$root;
		let index = item.$$index;
		if (item.children) {
			parent.some((node, i) => {
				if (node == item) {
					if (!item.$$expand) {
						let data = [i + 1, 0];
						item.children.map(childNode => data.push(childNode));
						parent.splice.apply(parent, data);
						item.$$expand = !item.$$expand;
					} else {
						let allExpand = this.findAllExpanded(item);
						allExpand.reverse();
						allExpand.map(item => {
							item.$$root.some((node, index) => {
								if (node == item) {
									item.$$root.splice(index + 1, node.children.length);
									item.$$expand = !item.$$expand;
									return true;
								}
							})
						})
					}
					return true;
				}
			})
		}
	}
}