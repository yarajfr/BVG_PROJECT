import { Component, ViewChildren, ElementRef, QueryList } from "@angular/core";
import { AnimationProvider } from "../../../providers/animation/animation";
import { ChangeDetectorRef } from "@angular/core";

export interface ToastOptions {
	/**背景颜色 */
	backgroundColor?: string;
	/**文字颜色 */
	color?: string;
	/**文字颜色,默认右下角
	 * rb	右下角
	 * rt	右上角
	 * ct	中上
	 * cc	正中间
	 * cb	中下
	 * lt	左上
	 * lb	左下
	 */
	position?: "rb" | "rt" | "ct" | "cc" | "cb" | "lt" | "lb";
	/**显示内容 */
	content: string;
	/**多少秒后隐藏，默认3秒 */
	timeout?: number;
	/**信息类型 */
	type?: "success" | "info" | "error" | "warning";
	/**显示图标 */
	icon?: string;
}

export interface PriviceToastOptions {
	/**dom */
	dom?: ElementRef;
	/**dom 高度 */
	height?: number;
	width?: number;
	/**控制显示dom */
	ready?: boolean;
	/**控制dom样式 */
	style?: any;
	/**延时函数 */
	timeoutFn?: any
	/**关闭 */
	close?: any;
}

@Component({
	templateUrl: "./toast.html",
	selector: "toast-view",
})
export class ToastComponent {
	text: string = '';
	static Instance: ToastComponent = null;
	// 右下角
	rightBC = [];
	@ViewChildren("rbcDom") rbcDom: QueryList<ElementRef>;
	// 右上角
	rightTC = [];
	@ViewChildren("rtcDom") rtcDom: QueryList<ElementRef>;
	// 中上
	centerTC = [];
	@ViewChildren("ctcDom") ctcDom: QueryList<ElementRef>;
	// 中上
	centerCC = [];
	@ViewChildren("cccDom") cccDom: QueryList<ElementRef>;
	// 中下
	centerBC = [];
	@ViewChildren("cbcDom") cbcDom: QueryList<ElementRef>;
	// 左上角
	leftTC = [];
	@ViewChildren("ltcDom") ltcDom: QueryList<ElementRef>;
	// 左下角
	leftBC = [];
	@ViewChildren("lbcDom") lbcDom: QueryList<ElementRef>;

	constructor(
		private animationProvider: AnimationProvider,
		private cdr: ChangeDetectorRef,
	) { }

	ngOnInit() {
		ToastComponent.Instance = this;
	}

	calcMsgType(option: ToastOptions) {
		switch (option.type) {
			case "success":
				[option.backgroundColor, option.color, option.icon] =
					[option.backgroundColor || "#27AE60", option.color || "#fff", option.icon || "fa-thumbs-o-up"];
				break;
			case "info":
				[option.backgroundColor, option.color, option.icon] =
					[option.backgroundColor || "#3498DB", option.color || "#fff", option.icon || "fa-smile-o"];
				break;
			case "error":
				[option.backgroundColor, option.color, option.icon] =
					[option.backgroundColor || "#E74C3C", option.color || "#fff", option.icon || "fa-frown-o"];
				break;
			case "warning":
				[option.backgroundColor, option.color, option.icon] =
					[option.backgroundColor || "#D35400", option.color || "#fff", option.icon || "fa-meh-o"];
				break;
			default:
				[option.backgroundColor, option.color, option.icon] =
					[option.backgroundColor || "#27AE60", option.color || "#fff", option.icon || "fa-smile-o"];
				break;
		}
	}

	/**检查提醒排列方向 */
	checkPosition(option: ToastOptions) {
		let data = [
			[this.rightTC, "rt", -1, this.rtcDom],
			[this.rightBC, "rb", 1, this.rbcDom],
			[this.centerTC, "ct", -1, this.ctcDom],
			[this.centerCC, "cc", 0, this.cccDom],
			[this.centerBC, "cb", 1, this.cbcDom],
			[this.leftTC, "lt", -1, this.ltcDom],
			[this.leftBC, "lb", 1, this.lbcDom],
		];
		let positionData;
		data.some(item => {
			if (option.position == item[1]) {
				positionData = item;
				return true;
			}
		})
		return positionData;
	}

	/**计算排列位置 */
	calcPosition(option: ToastOptions & PriviceToastOptions, list: any[], type: string, direction: number, domList: QueryList<ElementRef>) {
		option.style = {
			'background-color': option.backgroundColor,
			'color': option.color,
		}
		/**按方向判断插入点 */
		let index;
		if (direction == -1) {
			index = 0;
			list.unshift(option);
		} else if (direction == 1) {
			index = list.push(option) - 1;
		}
		let subscribe = domList.changes.subscribe(() => {
			return setTimeout(() => {
				subscribe.unsubscribe();
				let dom = domList.toArray()[index];
				option.dom = dom;
				let contentDom: HTMLElement = (dom.nativeElement as HTMLElement).getElementsByClassName("content")[0] as any;
				if (type == "ct" || type == "cb") {
					let contentWidth = contentDom.clientWidth;
					if (contentWidth > 650) {
						contentDom.style.width = '650px';
					}
					option.style.width = contentDom.clientWidth + 40 + 24 + 'px';
					this.animationProvider.fadeIn(dom.nativeElement);
				}
				let contentHeight = contentDom.clientHeight;
				option.height = contentHeight + 10;
				option.ready = true;
				option.style.height = option.height + "px";
				/**按方向计算间距 */
				if (direction == 1) {
					for (let i = index - 1; i >= 0; i--) {
						let o_option = list[i];
						let bottom = parseFloat(o_option.style.bottom || 0) + option.height + 16;
						o_option.style.bottom = bottom + "px";
					}
				} else if (direction == -1) {
					for (let i = index + 1; i < list.length; i++) {
						let o_option = list[i];
						let top = parseFloat(o_option.style.top || 0) + option.height + 16;
						o_option.style.top = top + "px";
					}
				}
				option.close = () => {
					clearTimeout(option.timeoutFn);
					/**按方向进行删除 */
					if (direction == 1) {
						for (let i = 0; ; i++) {
							let o_option = list[i];
							let bottom = parseFloat(o_option.style.bottom || 0) - option.height - 16;
							o_option.style.bottom = bottom + "px";
							if (o_option == option) {
								list.splice(i, 1)
								break;
							}
						}
					} else if (direction == -1) {
						for (let i = list.length - 1; ; i--) {
							let o_option = list[i];
							let top = parseFloat(o_option.style.top || 0) - option.height - 16;
							o_option.style.top = top + "px";
							if (o_option == option) {
								list.splice(i, 1)
								break;
							}
						}
					}
				}
				option.timeoutFn = setTimeout(() => {
					option.close();
				}, (option.timeout * 1000 || 0));
				this.cdr.detectChanges();
			}, 0)
		});
	}

	// 无表情 meh-o 哭脸 frown-o 笑脸 smile-o 大拇指 fa-thumbs-o-up
	create(option: ToastOptions) {
		if (!option.content) return;
		if (!option.position) option.position = "rb";
		this.calcMsgType(option);
		if (typeof option.timeout == "undefined") option.timeout = 3;
		let data: any[] = this.checkPosition(option);
		data.unshift(option);
		this.calcPosition.apply(this, data);
	}
}