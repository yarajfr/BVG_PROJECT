import { Component, TemplateRef } from "@angular/core";
import { ModalController } from "../../../providers/modal/modalController";
import { isBoolean } from "util";
import { ModalOptions } from "../modal";
import { FormBuilder } from "@angular/forms";
import { I18nProvider } from "../../../providers/i18n/i18n";

export interface InfoConfirmOptions extends ModalOptions {
    title?: string;
    image?: string;
    content?: string;
    hideOk?: boolean;
    okText?: string;
    beforeOk?: (data: any) => boolean | Promise<boolean>;
    hideCancel?: boolean;
    cancelText?: string;
    beforeCancel?: (data: any) => boolean | Promise<boolean>;
    buttons?: InfoConfirmButton[];
    buttonsCss?: string;
    css?: string;
    contentTpl?: TemplateRef<any>;
}

export interface InfoConfirmButton {
    text: string;
    cssClass?: string;
    canClose?: (data: any) => boolean | Promise<boolean>;
}

@Component({
    templateUrl: "./infoConfirm.html",
})
export class InfoConfirmComponent {
    data;
    form;
    constructor(
        private modalController: ModalController,
        private formBuilder: FormBuilder,
        private i18n: I18nProvider,
    ) { }
    content: string = "";
    buttons: InfoConfirmButton[];
    css: string = ""
    contentTpl: TemplateRef<any>;

    clicking: boolean;
    async buttonClick(btn: (InfoConfirmButton & { type?: "ok" | "cancel" })) {
        this.clicking = true;
        try {
            let result;
            if (btn.canClose) {
                result = await btn.canClose(this.data);
            }
            if (typeof result == "undefined") {
                if (btn.type == "ok") {
                    this.modalController.sendMessage(this.data);
                    this.modalController.close();
                } else if (btn.type == "cancel") {
                    this.modalController.sendError(this.data);
                    this.modalController.close();
                } else {
                    this.modalController.sendMessage(this.data || btn);
                    this.modalController.close();
                }
            } else {
                if (result) {
                    this.modalController.sendMessage(this.data || result);
                    this.modalController.close();
                } else {
                    this.modalController.sendError(this.data || result);
                }
            }
        } catch (e) { }
        this.clicking = false;
    }

    ngOnInit() {
        let options = this.modalController.params;
        if (typeof options == "string") {
            options = {
                content: options,
            }
        }
        this.deal(options);
        this.form = this.formBuilder.group({
            data: [""],
        })
    }

    deal(options: InfoConfirmOptions) {
        this.content = options.content;
        this.content = options.content;
        this.css = options.css;
        this.contentTpl = options.contentTpl;
        if (!options.buttons) {
            options.buttons = [];
            if (!isBoolean(options.hideCancel) || !options.hideCancel) {
                options.buttons.push({
                    /**取消 */
                    text: options.cancelText || this.i18n.get("__3"),
                    cssClass: "btn-default-outline",
                    canClose: options.beforeCancel,
                    type: "cancel",
                } as any)
            }
            if (!isBoolean(options.hideOk) || !options.hideOk) {
                options.buttons.push({
                    /**确定 */
                    text: options.okText || this.i18n.get("__2"),
                    cssClass: "btn-success",
                    canClose: options.beforeOk,
                    type: "ok",
                } as any)
            }
        }
        this.buttons = options.buttons;
    }

    ngOnDestroy() { }
}