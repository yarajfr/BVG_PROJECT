import { ChangeDetectorRef, Component, ElementRef, Inject, Input } from '@angular/core';
import { Icons } from '../../providers/icon.provider';
import { uppercamelcase } from '../../utils/utils';
/**
 * Bootstrap icon component.
 */
export class NgxBootstrapIconsLibComponent {
    constructor(elem, changeDetector, icons) {
        this.elem = elem;
        this.changeDetector = changeDetector;
        this.icons = icons;
    }
    /** OnChanges event. */
    ngOnChanges(changes) {
        // icons are provided as an array of objects because of "multi: true"
        const icons = Object.assign({}, ...this.icons);
        let svg = icons[uppercamelcase(changes.name.currentValue)] || '';
        if (!svg)
            console.warn(`Icon not found: ${changes.name.currentValue}\n`);
        if (this.width && svg.includes('width'))
            svg = svg.replace('width="1em"', `width="${this.width}"`);
        if (this.height && svg.includes('height'))
            svg = svg.replace('height="1em"', `height="${this.height}"`);
        this.elem.nativeElement.innerHTML = svg;
        this.changeDetector.markForCheck();
    }
}
NgxBootstrapIconsLibComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: 'i-bs',
                template: '<ng-content></ng-content>'
            },] }
];
NgxBootstrapIconsLibComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Icons, decorators: [{ type: Inject, args: [Icons,] }] }
];
NgxBootstrapIconsLibComponent.propDecorators = {
    name: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWJvb3RzdHJhcC1pY29ucy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vcHJvamVjdHMvbmd4LWJvb3RzdHJhcC1pY29ucy1saWIvc3JjLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvbmd4LWJvb3RzdHJhcC1pY29ucy9uZ3gtYm9vdHN0cmFwLWljb25zLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUN4RCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDdEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRW5EOztHQUVHO0FBTUgsTUFBTSxPQUFPLDZCQUE2QjtJQVV4QyxZQUNVLElBQWdCLEVBQ2hCLGNBQWlDLEVBRWpDLEtBQVk7UUFIWixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLG1CQUFjLEdBQWQsY0FBYyxDQUFtQjtRQUVqQyxVQUFLLEdBQUwsS0FBSyxDQUFPO0lBQ2xCLENBQUM7SUFFTCx1QkFBdUI7SUFDdkIsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLHFFQUFxRTtRQUNyRSxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxHQUFJLElBQUksQ0FBQyxLQUF5QixDQUFDLENBQUM7UUFDcEUsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWpFLElBQUksQ0FBQyxHQUFHO1lBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO1FBQ3pFLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztZQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxVQUFVLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ25HLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztZQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxXQUFXLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBRXhHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUM7UUFDeEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNyQyxDQUFDOzs7WUFsQ0YsU0FBUyxTQUFDO2dCQUNULCtDQUErQztnQkFDL0MsUUFBUSxFQUFFLE1BQU07Z0JBQ2hCLFFBQVEsRUFBRSwyQkFBMkI7YUFDdEM7OztZQWIrQixVQUFVO1lBQXhDLGlCQUFpQjtZQUdWLEtBQUssdUJBd0JULE1BQU0sU0FBQyxLQUFLOzs7bUJBWGQsS0FBSztvQkFHTCxLQUFLO3FCQUdMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlc1xyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJY29uTmFtZXNFbnVtIH0gZnJvbSAnLi4vLi4vZW51bXMvaWNvbi1uYW1lcy5lbnVtJztcclxuaW1wb3J0IHsgSWNvbnMgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvaWNvbi5wcm92aWRlcic7XHJcbmltcG9ydCB7IHVwcGVyY2FtZWxjYXNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEJvb3RzdHJhcCBpY29uIGNvbXBvbmVudC5cclxuICovXHJcbkBDb21wb25lbnQoe1xyXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogY29tcG9uZW50LXNlbGVjdG9yXHJcbiAgc2VsZWN0b3I6ICdpLWJzJyxcclxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4Qm9vdHN0cmFwSWNvbnNMaWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xyXG4gIC8qKiBJY29uIG5hbWUuICovXHJcbiAgQElucHV0KCkgbmFtZSE6IHN0cmluZyB8IEljb25OYW1lc0VudW07XHJcblxyXG4gIC8qKiBJY29uIHdpZHRoLiAqL1xyXG4gIEBJbnB1dCgpIHdpZHRoITogc3RyaW5nO1xyXG5cclxuICAvKiogSWNvbiBoZWlnaHQuICovXHJcbiAgQElucHV0KCkgaGVpZ2h0ITogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgZWxlbTogRWxlbWVudFJlZixcclxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgQEluamVjdChJY29ucylcclxuICAgIHByaXZhdGUgaWNvbnM6IEljb25zLFxyXG4gICkgeyB9XHJcblxyXG4gIC8qKiBPbkNoYW5nZXMgZXZlbnQuICovXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgLy8gaWNvbnMgYXJlIHByb3ZpZGVkIGFzIGFuIGFycmF5IG9mIG9iamVjdHMgYmVjYXVzZSBvZiBcIm11bHRpOiB0cnVlXCJcclxuICAgIGNvbnN0IGljb25zID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uKHRoaXMuaWNvbnMgYXMgYW55IGFzIG9iamVjdFtdKSk7XHJcbiAgICBsZXQgc3ZnID0gaWNvbnNbdXBwZXJjYW1lbGNhc2UoY2hhbmdlcy5uYW1lLmN1cnJlbnRWYWx1ZSldIHx8ICcnO1xyXG5cclxuICAgIGlmICghc3ZnKSBjb25zb2xlLndhcm4oYEljb24gbm90IGZvdW5kOiAke2NoYW5nZXMubmFtZS5jdXJyZW50VmFsdWV9XFxuYCk7XHJcbiAgICBpZiAodGhpcy53aWR0aCAmJiBzdmcuaW5jbHVkZXMoJ3dpZHRoJykpIHN2ZyA9IHN2Zy5yZXBsYWNlKCd3aWR0aD1cIjFlbVwiJywgYHdpZHRoPVwiJHt0aGlzLndpZHRofVwiYCk7XHJcbiAgICBpZiAodGhpcy5oZWlnaHQgJiYgc3ZnLmluY2x1ZGVzKCdoZWlnaHQnKSkgc3ZnID0gc3ZnLnJlcGxhY2UoJ2hlaWdodD1cIjFlbVwiJywgYGhlaWdodD1cIiR7dGhpcy5oZWlnaHR9XCJgKTtcclxuXHJcbiAgICB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5pbm5lckhUTUwgPSBzdmc7XHJcbiAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xyXG4gIH1cclxufVxyXG4iXX0=